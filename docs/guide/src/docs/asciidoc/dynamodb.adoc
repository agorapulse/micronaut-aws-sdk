=== DynamoDB

> Amazon DynamoDB is a fully managed NoSQL database service that provides fast and predictable performance with seamless scalability.

This library provides two approaches to work with DynamoDB tables and entities:

1. High-level <<Declarative Services with `@Service`>>
2. Middle-level <<DynamoDB Service>>

==== Installation


[source,indent=0,role="primary",subs='verbatim,attributes']
.Gradle (AWS SDK 2.x)
----
annotationProcessor 'com.agorapulse:micronaut-amazon-awssdk-dynamodb-annotation-processor:{project-version}'
implementation 'com.agorapulse:micronaut-amazon-awssdk-dynamodb:{project-version}'

// for Kotlin Query DSL
implementation 'com.agorapulse:micronaut-amazon-awssdk-dynamodb-kotlin:{project-version}'
----

[source,xml,indent=0,role="secondary",subs='verbatim,attributes']
.Maven (AWS SDK 2.x)
----
<dependency>
    <groupId>com.agorapulse</groupId>
    <artifactId>micronaut-amazon-awssdk-dynamodb</artifactId>
    <version>{project-version}</version>
</dependency>
<!-- for Kotlin Query DSL -->
<dependency>
    <groupId>com.agorapulse</groupId>
    <artifactId>micronaut-amazon-awssdk-dynamodb</artifactId>
    <version>{project-version}</version>
</dependency>
----

[source,indent=0,role="secondary",subs='verbatim,attributes']
.Gradle (AWS SDK 1.x)
----
annotationProcessor 'com.agorapulse:micronaut-aws-sdk-dynamodb-annotation-processor:{project-version}'
implementation 'com.agorapulse:micronaut-aws-sdk-dynamodb:{project-version}'
----

[source,xml,indent=0,role="secondary",subs='verbatim,attributes']
.Maven (AWS SDK 1.x)
----
<dependency>
    <groupId>com.agorapulse</groupId>
    <artifactId>micronaut-aws-sdk-dynamodb</artifactId>
    <version>{project-version}</version>
</dependency>
----

NOTE: For Kotlin use `kapt` instead of `annotationProcessor` configuration.

==== Entity Class

The entity class is a class which instances represent the items in DynamoDB.

For AWS SDK v2 you don't need to use the https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/enhanced/dynamodb/mapper/annotations/package-summary.html[native annotations] but
you fill their counterparts in `com.agorapulse.micronaut.amazon.awssdk.dynamodb.annotation` package. The only requirements is that
the class needs to be annotated either with `@Introspected` or `@DynamoDbBean`. There is a replacement for `@DynamoDBTypeConvertedJson` annotation as well - you can use `@ConvertedJson` annotation instead.



[source,groovy,indent=0,options="nowrap",role="primary"]
.Groovy
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/groovy/DynamoDBEntity.groovy[lines=19..-1]
----
<1> The entity must be annotated with `@Introspected` or `@DynamoDBBean`
<2> The entity must provide the partition key using `@ParitionKey` annotation
<3> The sort key is optional
<4> The secondary indices are generated automatically if not present
<5> If the secondary indices are generated then the projection type must be specified (the default is KEYS_ONLY)
<6> The secondary indices can be read only if you derive them from the other attributes
<7> You can use `@TimeToLive` annotation to specify the attribute which will be used for TTL. The annotation used on class level, the `Instant.now()` will be used as a reference time.


[source,java,indent=0,options="nowrap",role="secondary"]
.Java
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DynamoDBEntity.java[lines=19..-1]
----
<1> The entity must be annotated with `@Introspected` or `@DynamoDBBean`
<2> The entity must provide the partition key using `@ParitionKey` annotation
<3> The sort key is optional
<4> The secondary indices are generated automatically if not present
<5> If the secondary indices are generated then the projection type must be specified (the default is KEYS_ONLY)
<6> The secondary indices can be read only if you derive them from the other attributes
<7> You can use `@TimeToLive` annotation to specify the attribute which will be used for TTL. The annotation used on class level, the `Instant.now()` will be used as a reference time.

[source,kotlin,indent=0,options="nowrap",role="secondary"]
.Kotlin
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb-kotlin/src/test/kotlin/com/agorapulse/micronaut/amazon/awssdk/dynamodb/kotlin/DynamoDBEntity.kt[lines=19..-1]
----
<1> The entity must be annotated with `@Introspected` or `@DynamoDBBean`
<2> The entity must provide the partition key using `@ParitionKey` annotation
<3> The sort key is optional
<4> The secondary indices are generated automatically if not present
<5> If the secondary indices are generated then the projection type must be specified (the default is KEYS_ONLY)
<6> The secondary indices can be read only if you derive them from the other attributes
<7> You can use `@TimeToLive` annotation to specify the attribute which will be used for TTL. The annotation used on class level, the `Instant.now()` will be used as a reference time.

WARNING: The `@TimeToLive` annotation only adds read only attribute to the entity. You need to enable TTL on the table manually.

==== Declarative Services with `@Service`

Declarative services are very similar to http://gorm.grails.org/6.1.x/hibernate/manual/#dataServices[Grails GORM Data Services].
If you place `Service` annotation on the interface then methods matching predefined pattern will be automatically implemented.

NOTE: For AWS SDK 2.x, use packages starting `com.agorapulse.micronaut.amazon.awssdk.dynamodb`.

NOTE: For AWS SDK 1.x, use packages starting `com.agorapulse.micronaut.aws.sdk.dynamodb`.

===== Method Signatures

The following example shows many of available method signatures:

[source,groovy,indent=0,options="nowrap",role="primary"]
.Groovy
----
@Service(DynamoDBEntity)
interface DynamoDBItemDBService {

    DynamoDBEntity get(String hash, String rangeKey)
    DynamoDBEntity load(String hash, String rangeKey)
    List<DynamoDBEntity> getAll(String hash, List<String> rangeKeys)
    List<DynamoDBEntity> getAll(String hash, String... rangeKeys)
    List<DynamoDBEntity> loadAll(String hash, List<String> rangeKeys)
    List<DynamoDBEntity> loadAll(String hash, String... rangeKeys)

    DynamoDBEntity save(DynamoDBEntity entity)
    List<DynamoDBEntity> saveAll(DynamoDBEntity... entities)
    List<DynamoDBEntity> saveAll(Iterable<DynamoDBEntity> entities)

    int count(String hashKey)
    int count(String hashKey, String rangeKey)

    @Query({
        query(DynamoDBEntity) {
            hash hashKey
            range {
                eq DynamoDBEntity.RANGE_INDEX, rangeKey
            }
        }
    })
    int countByRangeIndex(String hashKey, String rangeKey)

    @Query({
        query(DynamoDBEntity) {
            hash hashKey
            range { between DynamoDBEntity.DATE_INDEX, after, before }
        }
    })
    int countByDates(String hashKey, Date after, Date before)

    Publisher<DynamoDBEntity> query(String hashKey)
    Publisher<DynamoDBEntity> query(String hashKey, String rangeKey)

    @Query({
        query(DynamoDBEntity) {
            hash hashKey
            range {
                eq DynamoDBEntity.RANGE_INDEX, rangeKey
            }
            only {
                rangeIndex
            }
        }
    })
    Publisher<DynamoDBEntity> queryByRangeIndex(String hashKey, String rangeKey)

    @Query({
        query(DynamoDBEntity) {
            hash hashKey
            range { between DynamoDBEntity.DATE_INDEX, after, before }
        }
    })
    List<DynamoDBEntity> queryByDates(String hashKey, Date after, Date before)

    void delete(DynamoDBEntity entity)
    void delete(String hashKey, String rangeKey)

    @Query({
        query(DynamoDBEntity) {
            hash hashKey
            range {
                eq DynamoDBEntity.RANGE_INDEX, rangeKey
            }
        }
    })
    int deleteByRangeIndex(String hashKey, String rangeKey)

    @Query({
        query(DynamoDBEntity) {
            hash hashKey
            range { between DynamoDBEntity.DATE_INDEX, after, before }
        }
    })
    int deleteByDates(String hashKey, Date after, Date before)

    @Update({
        update(DynamoDBEntity) {
            hash hashKey
            range rangeKey
            add 'number', 1
            returnUpdatedNew { number }
        }
    })
    Number increment(String hashKey, String rangeKey)

    @Update({
        update(DynamoDBEntity) {
            hash hashKey
            range rangeKey
            add 'number', -1
            returnUpdatedNew { number }
        }
    })
    Number decrement(String hashKey, String rangeKey)

    @Scan({
        scan(DynamoDBEntity) {
            filter {
                eq DynamoDBEntity.RANGE_INDEX, foo
            }
        }
    })
    Publisher<DynamoDBEntity> scanAllByRangeIndex(String foo)

}
----

[source,java,indent=0,options="nowrap",role="secondary"]
.Java
----
@Service(DynamoDBEntity.class)
public interface DynamoDBEntityService {

    class EqRangeIndex implements Function<Map<String, Object>, DetachedQuery> {
        public DetachedQuery apply(Map<String, Object> arguments) {
            return Builders.query(DynamoDBEntity.class)
                .hash(arguments.get("hashKey"))
                .range(r -> r.eq(DynamoDBEntity.RANGE_INDEX, arguments.get("rangeKey")));
        }
    }

    class EqRangeProjection implements Function<Map<String, Object>, DetachedQuery> {
        public DetachedQuery apply(Map<String, Object> arguments) {
            return Builders.query(DynamoDBEntity.class)
                .hash(arguments.get("hashKey"))
                .range(r ->
                    r.eq(DynamoDBEntity.RANGE_INDEX, arguments.get("rangeKey"))
                )
                .only(DynamoDBEntity.RANGE_INDEX);
        }
    }

    class EqRangeScan implements Function<Map<String, Object>, DetachedScan> {
        public DetachedScan apply(Map<String, Object> arguments) {
            return Builders.scan(DynamoDBEntity.class)
                .filter(f -> f.eq(DynamoDBEntity.RANGE_INDEX, arguments.get("foo")));
        }
    }

    class BetweenDateIndex implements Function<Map<String, Object>, DetachedQuery> {
        public DetachedQuery apply(Map<String, Object> arguments) {
            return Builders.query(DynamoDBEntity.class)
                .hash(arguments.get("hashKey"))
                .range(r -> r.between(DynamoDBEntity.DATE_INDEX, arguments.get("after"), arguments.get("before")));
        }
    }

    class IncrementNumber implements Function<Map<String, Object>, DetachedUpdate> {
        public DetachedUpdate apply(Map<String, Object> arguments) {
            return Builders.update(DynamoDBEntity.class)
                .hash(arguments.get("hashKey"))
                .range(arguments.get("rangeKey"))
                .add("number", 1)
                .returnUpdatedNew(DynamoDBEntity::getNumber);
        }
    }

    class DecrementNumber implements Function<Map<String, Object>, DetachedUpdate> {
        public DetachedUpdate apply(Map<String, Object> arguments) {
            return Builders.update(DynamoDBEntity.class)
                .hash(arguments.get("hashKey"))
                .range(arguments.get("rangeKey"))
                .add("number", -1)
                .returnUpdatedNew(DynamoDBEntity::getNumber);
        }
    }

    DynamoDBEntity get(String hash, String rangeKey);

    DynamoDBEntity load(String hash, String rangeKey);

    List<DynamoDBEntity> getAll(String hash, List<String> rangeKeys);

    List<DynamoDBEntity> getAll(String hash, String... rangeKeys);

    List<DynamoDBEntity> loadAll(String hash, List<String> rangeKeys);

    List<DynamoDBEntity> loadAll(String hash, String... rangeKeys);

    DynamoDBEntity save(DynamoDBEntity entity);

    List<DynamoDBEntity> saveAll(DynamoDBEntity... entities);

    List<DynamoDBEntity> saveAll(Iterable<DynamoDBEntity> entities);

    int count(String hashKey);

    int count(String hashKey, String rangeKey);

    @Query(EqRangeIndex.class)
    int countByRangeIndex(String hashKey, String rangeKey);

    @Query(BetweenDateIndex.class)
    int countByDates(String hashKey, Date after, Date before);

    Publisher<DynamoDBEntity> query(String hashKey);

    Publisher<DynamoDBEntity> query(String hashKey, String rangeKey);

    @Query(EqRangeProjection.class)
    Publisher<DynamoDBEntity> queryByRangeIndex(String hashKey, String rangeKey);

    @Query(BetweenDateIndex.class)
    List<DynamoDBEntity> queryByDates(String hashKey, Date after, Date before);

    void delete(DynamoDBEntity entity);

    void delete(String hashKey, String rangeKey);

    @Query(EqRangeIndex.class)
    int deleteByRangeIndex(String hashKey, String rangeKey);

    @Query(BetweenDateIndex.class)
    int deleteByDates(String hashKey, Date after, Date before);

    @Update(IncrementNumber.class)
    Number increment(String hashKey, String rangeKey);

    @Update(DecrementNumber.class)
    Number decrement(String hashKey, String rangeKey);

    @Scan(EqRangeScan.class)
    Publisher<DynamoDBEntity> scanAllByRangeIndex(String foo);

}
----


[source,kotlin,indent=0,options="nowrap",role="secondary"]
.Kotlin
----
@Service(value = DynamoDBEntity::class, tableName = "DynamoDBJava")
interface DynamoDBEntityService {

    fun sget(@PartitionKey parentId: String, @SortKey id: String): DynamoDBEntity

    fun load(@PartitionKey parentId: String, @SortKey id: String): DynamoDBEntity

    fun getAll(hash: String, rangeKeys: List<String>): List<DynamoDBEntity>

    fun getAll(hash: String, vararg rangeKeys: String): List<DynamoDBEntity>

    fun loadAll(hash: String, rangeKeys: List<String>): List<DynamoDBEntity>

    fun loadAll(hash: String, vararg rangeKeys: String): List<DynamoDBEntity>

    fun save(entity: DynamoDBEntity): DynamoDBEntity

    fun saveAll(vararg entities: DynamoDBEntity): List<DynamoDBEntity?>?

    fun saveAll(entities: Iterable<DynamoDBEntity>): List<DynamoDBEntity>

    fun count(hashKey: String): Int

    fun count(hashKey: String, rangeKey: String): Int

    class EqRangeIndex : QueryFunction<DynamoDBEntity>({ args: Map<String, Any> ->
        partitionKey(args.get("hashKey"))
        index(DynamoDBEntity.RANGE_INDEX)
        sortKey {
            eq(args["rangeKey"])
        }
    })

    @Query(EqRangeIndex::class)
    fun countByRangeIndex(hashKey: String, rangeKey: String): Int

    class BetweenDateIndex : QueryFunction<DynamoDBEntity>({ args: Map<String, Any> ->
        index(DynamoDBEntity.DATE_INDEX)
        partitionKey(args["hashKey"])
        sortKey { between(args["after"], args["before"]) }
        page(1)
    })

    @Query(BetweenDateIndex::class)
    fun countByDates(hashKey: String, after: Date, before: Date): Int

    fun query(hashKey: String): Publisher<DynamoDBEntity>
    fun query(hashKey: String, rangeKey: String): Publisher<DynamoDBEntity>

    class EqRangeProjection : QueryFunction<DynamoDBEntity>({ args: Map<String, Any> ->
        partitionKey(args["hashKey"])
        index(DynamoDBEntity.RANGE_INDEX)
        sortKey { eq(args["rangeKey"]) }
        only(DynamoDBEntity.RANGE_INDEX)
    })
    @Query(EqRangeProjection::class)
    fun queryByRangeIndex(hashKey: String, rangeKey: String): Publisher<DynamoDBEntity>

    @Query(BetweenDateIndex::class)
    fun queryByDates(hashKey: String, after: Date, before: Date): List<DynamoDBEntity>

    class BetweenDateIndexScroll : QueryFunction<DynamoDBEntity>({ args: Map<String, Any> ->
        index(DynamoDBEntity.DATE_INDEX)
        partitionKey(args["hashKey"])
        lastEvaluatedKey(args["lastEvaluatedKey"])
        sortKey { between(args["after"], args["before"]) }
    })

    @Query(BetweenDateIndexScroll::class)
    fun queryByDatesScroll(
        hashKey: String,
        after: Date,
        before: Date,
        lastEvaluatedKey: DynamoDBEntity
    ): List<DynamoDBEntity>

    fun delete(entity: DynamoDBEntity)
    fun delete(hashKey: String, rangeKey: String)

    @Query(EqRangeIndex::class)
    fun deleteByRangeIndex(hashKey: String, rangeKey: String): Int

    @Query(BetweenDateIndex::class)
    fun deleteByDates(hashKey: String, after: Date, before: Date): Int
    class IncrementNumber : UpdateFunction<DynamoDBEntity, Int>({ args: Map<String, Any> ->
        partitionKey(args["hashKey"])
        sortKey(args["rangeKey"])
        add("number", 1)
        returnUpdatedNew(DynamoDBEntity::number)
    })

    @Update(IncrementNumber::class)
    fun increment(hashKey: String, rangeKey: String): Number
    class DecrementNumber : UpdateFunction<DynamoDBEntity, Int>({ args: Map<String, Any> ->
        partitionKey(args["hashKey"])
        sortKey(args["rangeKey"])
        add("number", -1)
        returnUpdatedNew(DynamoDBEntity::number)
    })

    @Update(DecrementNumber::class)
    fun decrement(hashKey: String, rangeKey: String): Number
    class EqRangeScan : ScanFunction<DynamoDBEntity>({ args: Map<String, Any> ->
        filter {
            eq(DynamoDBEntity.RANGE_INDEX, args["foo"])
        }

    })
    @Scan(EqRangeScan::class)
    fun scanAllByRangeIndex(foo: String): Publisher<DynamoDBEntity>
}
----

The following table summarizes the supported method signatures:

.Basic Service Methods
|===
|Return Type | Method Name | Arguments | Example | Description

|
    `T`

    `List<T>`
| `save*`
| An entity, array of entities or iterable of entities
|
    `DynamoDBEntity save(DynamoDBEntity entity)`

    `List<DynamoDBEntity> saveAll(DynamoDBEntity... entities)`

| Persists the entity or a list of entities and returns self


|
    `T`

    `List<T>`
| `get*`, `load*`
| Hash key and optional range key, array of range keys or iterable of range keys annotated with `@HashKey` and `@RangeKey` if the argument name does not contain word `hash` or `range`
|
    `DynamoDBEntity load(String hashKey);`

    `List<DynamoDBEntity> getAll(@HashKey String parentId, String... rangeKeys);`

    `List<DynamoDBEntityNoRange> getAll(@HashKey List<String> parentIds);`

| Loads a single entity or a list of entities from the table. Range key is required for tables which defines the range key


| `int`
| `count*`
| Hash key and optional range key annotated with `@HashKey` and `@RangeKey` if the argument name does not contain word `hash` or `range`
|

    `int count(String hashKey)`

    `int count(@HashKey String parentId, String rangeKey)`

| Counts the items in the database. Beware, this can be very expensive operation in DynamoDB. See <<Advanced Queries>> for advanced use cases

| `void`
| `delete*`
| Entity or Hash key and optional range key annotated with `@HashKey` and `@RangeKey` if the argument name does not contain word `hash` or `range`
|

    `void delete(DynamoDBEntity entity)`

    `void delete(String hashKey, String rangeKey)`

| Deletes an item which can be specified with hash key and optional range key. See <<Advanced Queries>> for advanced use cases

| `Publisher<T>`
|
`list*`

`findAll*`

`query*`

| Entity or Hash key and optional range key annotated with `@HashKey` and `@RangeKey` if the argument name does not contain word `hash` or `range`
|
    `Publisher<DynamoDBEntity> query(String hashKey)`

    `List<DynamoDBEntity> query(String hashKey, String rangeKey)`

| Queries for all entities with given hash key and/or range key.


|

    (contextual)
| (none of above)
| Any arguments which will be translated into arguments map
|

(see below)

| Query, scan or update. See <<Advanced Queries>>, <<Scanning>> and <<Updates>> for advanced use cases

|===

TIP: Calling any of the declarative service method will create the DynamoDB table automatically if it does not exist already.

===== Advanced Queries

DynamoDB integration does not support feature known as http://gorm.grails.org/6.0.x/hibernate/manual/index.html#finders[_dynamic finders_].
Instead you can annotate any method with `@Query` annotation to make it

 * counting method if its name begins with `count`
 * batch delete method if its name begins with `delete`
 * otherwise an advanced query method

For DynamoDB v2 you can use `@Index`, `@Consistent` `@Descending`, `@Filter`, `@Limit`, `@Page` and `@LastEvaluatedKey` annotations to further customize the query without the need of creating a custom query class and use it with `@Query` annotation.

[source,java,indent=0,options="nowrap"]
.Advanced Query Annotations
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DynamoDBEntityService.java[tags=advanced-query-methods]
----
<1> You can use `@Consistent` annotation to make the query consistent
<2> You can use `@Descending` annotation to sort the results in descending order
<3> You can use `@Index` annotation to specify the index to use to query the table
<4> Any parameters that are not partition or sort keys are used as filter conditions
<5> If the parameter is annotated with `@Nullable` then the filter condition is only applied when the parameter is not `null`
<6> You can use `@Filter` annotation to specify the filter condition operator
<7> You can use `@Filter` annotation to specify the attribute name
<8> You can combine `@SortKey` and `@Filter` annotations to specify the sort key condition
<9> Only`EQ`, `LE`, `LT`, `GE`, `GT`, `BETWEEN` and `BEGINS_WITH` operators are supported
<10> You can also use `@Filter` annotation to specify the sort key name
<11> If you use any customization annotations on delete method, then the method will be used as batch delete method
<12> You can pass the last evaluated key to the query. It must be the same type as the entity type.
<13> You can use `@Page` annotation to give the query the pagination hint
<14> You can use `@Limit` annotation to specify the maximum number of items to return

TIP: The operator `EQ` is used by default if `@Filter` annotation is not present. This makes it special and the service introduction tries to find the appropriate operation based on the actual value. For collections or arrays, `inList` operation is actually used. If the actual value is `null` then `isNull` operation is used. For other types, `eq` operation is used. For sort keys, `eq` operation is always used.

For more complex queries you can use `@Query` annotation with a class implementing `QueryFunction` interface:

[source,groovy,indent=0,options="nowrap",role="primary"]
.Groovy (AWS SDK 2.x)
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=builders-import]
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=service-header]
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=sample-queries]
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=service-footer]
----
<1> `GroovyBuilders` class provides all necessary factory methods and keywords
<2> Annotate an interface with `@Service` with the type of the entity as its `value`
<3> `@Query` annotation accepts a closure which returns a query builder (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/QueryBuilder.html[QueryBuilder] for full reference)
<4> Specify a partition key with `partitionKey` method and method's `hashKey` argument
<5> Specify some range key criteria with the method's `rangeKey` argument (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/RangeConditionCollector.html[RangeConditionCollector] for full reference)
<6> You can limit which properties are returned from the query
<7> Only `rangeIndex` property will be populated in the entities returned
<8> The arguments have no special meaning but you can use them in the query. The method must return either `Publisher`, `Stream` or `Iterable` of entities.

[source,java,indent=0,options="nowrap",role="secondary"]
.Java
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DynamoDBEntityService.java[tags=header]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DynamoDBEntityService.java[tags=sample-query-class]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DynamoDBEntityService.java[tags=sample-query]

}
----
<1> Annotate an interface with `@Service` with the type of the entity as its `value`
<2> Define class which implements `QueryFunction`
<3> Specify a partition key with `partitionKey` method and method's `hashKey` argument
<4> Specify some range key criteria with the method's `rangeKey` argument (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/RangeConditionCollector.html[RangeConditionCollector] for full reference)
<5> Only `rangeIndex` property will be populated in the entities returned
<6> `@Query` annotation accepts a class which implements `Function<Map<String, Object>, DetachedQuery>`
<7> The arguments have no special meaning but you can use them in the query using `arguments` map. The method must return either `Publisher`, `Stream` or `List` of entities.


[source,kotlin,indent=0,options="nowrap",role="secondary"]
.Kotlin

----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb-kotlin/src/test/kotlin/com/agorapulse/micronaut/amazon/awssdk/dynamodb/kotlin/DynamoDBEntityService.kt[tags=header]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb-kotlin/src/test/kotlin/com/agorapulse/micronaut/amazon/awssdk/dynamodb/kotlin/DynamoDBEntityService.kt[tags=sample-query-class]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb-kotlin/src/test/kotlin/com/agorapulse/micronaut/amazon/awssdk/dynamodb/kotlin/DynamoDBEntityService.kt[tags=sample-query]

}
----
<1> Annotate an interface with `@Service` with the type of the entity as its `value`
<2> Create class that extends `com.agorapulse.micronaut.amazon.awssdk.dynamodb.kotlin.QueryFunction` and use the DSL constructor
<3> Specify a partition key with `partitionKey` method and method's `hashKey` argument
<4> Specify some range key criteria with the method's `rangeKey` argument (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/RangeConditionCollector.html[RangeConditionCollector] for full reference)
<5> Only `rangeIndex` property will be populated in the entities returned
<6> `@Query` annotation accepts a class which implements `Function<Map<String, Object>, DetachedQuery>`
<7> The arguments have no special meaning but you can use them in the query using `arguments` map. The method must return either `Publisher`, `Stream` or `List` of entities.


[source,groovy,indent=0,options="nowrap",role="secondary"]
.Groovy  (AWS SDK 1.x)
----
include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=builders-import]
include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=service-header]
include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=sample-queries]
include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=service-footer]
----
<1> `Builders` class provides all necessary factory methods and keywords
<2> Annotate an interface with `@Service` with the type of the entity as its `value`
<3> `@Query` annotation accepts a closure which returns a query builder (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/QueryBuilder.html[QueryBuilder] for full reference)
<4> Specify a partition key with `partitionKey` method and method's `hashKey` argument
<5> Specify some range key criteria with the method's `rangeKey` argument (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/RangeConditionCollector.html[RangeConditionCollector] for full reference)
<6> You can limit which properties are returned from the query
<7> Only `rangeIndex` property will be populated in the entities returned
<8> The arguments have no special meaning but you can use them in the query. The method must return either `Publisher`, `Stream` or `List` of entities.

===== Scanning

DynamoDB integration does not support feature known as http://gorm.grails.org/6.0.x/hibernate/manual/index.html#finders[_dynamic finders_].
If you need to scan the table by unindexed attributes you can annotate any method with `@Scan` annotation to make it

 * counting method if its name begins with `count`
 * otherwise an advanced query method

[source,groovy,indent=0,options="nowrap",role="primary"]
.Groovy (AWS SDK 2.x)
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=builders-import]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=service-header]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=sample-scan]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=service-footer]
----
<1> `GroovyBuilders` class provides all necessary factory methods and keywords
<2> Annotate an interface with `@Service` with the type of the entity as its `value`
<3> `@Scan` annotation accepts a closure which returns a scan builder (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/ScanBuilder.html[ScanBuilder] for full reference)
<4> Specify some filter criteria with the method's `foo` argument (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/RangeConditionCollector.html[RangeConditionCollector] for full reference)
<5> The arguments have no special meaning but you can use them in the scan definition. The method must return either `Publisher`, `Stream` or `List` of entities.


[source,java,indent=0,options="nowrap",role="secondary"]
.Java
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DynamoDBEntityService.java[tags=header]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DynamoDBEntityService.java[tags=sample-scan-class]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DynamoDBEntityService.java[tags=sample-scan]

}
----
<1> Annotate an interface with `@Service` with the type of the entity as its `value`
<2> Define class which implements `ScanFunction`
<3> Specify some filter criteria with the method's `foo` argument (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/RangeConditionCollector.html[RangeConditionCollector] for full reference)
<4> `@Scan` annotation accepts a class which implements `Function<Map<String, Object>, DetachedScan>`
<5> The arguments have no special meaning but you can use them in the scan definition. The method must return either `Publisher`, `Stream` or `List` of entities.

[source,kotlin,indent=0,options="nowrap",role="secondary"]
.Kotlin
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb-kotlin/src/test/kotlin/com/agorapulse/micronaut/amazon/awssdk/dynamodb/kotlin/DynamoDBEntityService.kt[tags=header]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb-kotlin/src/test/kotlin/com/agorapulse/micronaut/amazon/awssdk/dynamodb/kotlin/DynamoDBEntityService.kt[tags=sample-scan-class]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb-kotlin/src/test/kotlin/com/agorapulse/micronaut/amazon/awssdk/dynamodb/kotlin/DynamoDBEntityService.kt[tags=sample-scan]

}
----
<1> Annotate an interface with `@Service` with the type of the entity as its `value`
<2> Define class which implements `ScanFunction`
<3> Specify some filter criteria with the method's `foo` argument (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/RangeConditionCollector.html[RangeConditionCollector] for full reference)
<4> `@Scan` annotation accepts a class which implements `Function<Map<String, Object>, DetachedScan>`
<5> The arguments have no special meaning but you can use them in the scan definition. The method must return either `Publisher`, `Stream` or `List` of entities.

[source,groovy,indent=0,options="nowrap",role="secondary"]
.Groovy  (AWS SDK 1.x)
----
include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=builders-import]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=service-header]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=sample-scan]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=service-footer]
----
<1> `Builders` class provides all necessary factory methods and keywords
<2> Annotate an interface with `@Service` with the type of the entity as its `value`
<3> `@Scan` annotation accepts a closure which returns a scan builder (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/ScanBuilder.html[ScanBuilder] for full reference)
<4> Specify some filter criteria with the method's `foo` argument (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/RangeConditionCollector.html[RangeConditionCollector] for full reference)
<5> The arguments have no special meaning but you can use them in the scan definition. The method must return either `Publisher`, `Stream` or `List` of entities.


=====  Updates
Declarative services allows you to execute fine-grained updates. Any method annotated with `@Update` will perform the update in the DynamoDB table.

[source,groovy,indent=0,options="nowrap",role="primary"]
.Groovy (AWS SDK 2.x)
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=builders-import]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=service-header]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=sample-update]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=service-footer]
----
<1> `Builders` class provides all necessary factory methods and keywords
<2> Annotate an interface with `@Service` with the type of the entity as its `value`
<3> `@Update` annotation accepts a closure which returns an update builder (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/UpdateBuilder.html[UpdateBuilder] for full reference)
<4> Specify a partition key with `partitionKey` method and method's `hashKey` argument
<5> Specify a sort key with `sortKey` method and method's `rangeKey` argument
<6> Specify update operation - increment `number` attribute (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/UpdateBuilder.html[UpdateBuilder] for full reference). You may have multiple update operations.
<7> Specify what should be returned from the method (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/UpdateBuilder.html[UpdateBuilder] for full reference).
<8> The arguments have no special meaning but you can use them in the scan definition. The method's return value depends on the value returned from `returnUpdatedNew` mapper.


[source,java,indent=0,options="nowrap",role="secondary"]
.Java
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DynamoDBEntityService.java[tags=header]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DynamoDBEntityService.java[tags=sample-update-class]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DynamoDBEntityService.java[tags=sample-update]

}
----
<1> Annotate an interface with `@Service` with the type of the entity as its `value`
<2> Define class which implements `Function<Map<String, Object>, DetachedUpdate>`
<3> Specify a partition key with `partitionKey` method and method's `hashKey` argument
<4> Specify a sort key with `sortKey` method and method's `rangeKey` argument
<5> Specify update operation - increment `number` attribute (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/UpdateBuilder.html[UpdateBuilder] for full reference). You may have multiple update operations.
<6> Specify what should be returned from the method (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/UpdateBuilder.html[UpdateBuilder] for full reference).
<7> `@Update` annotation accepts a class which implements `Function<Map<String, Object>, DetachedUpdate>`
<8> The arguments have no special meaning but you can use them in the scan definition. The method's return value depends on the value returned from `returnUpdatedNew` mapper.

[source,kotlin,indent=0,options="nowrap",role="secondary"]
.Kotlin
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb-kotlin/src/test/kotlin/com/agorapulse/micronaut/amazon/awssdk/dynamodb/kotlin/DynamoDBEntityService.kt[tags=header]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb-kotlin/src/test/kotlin/com/agorapulse/micronaut/amazon/awssdk/dynamodb/kotlin/DynamoDBEntityService.kt[tags=sample-update-class]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb-kotlin/src/test/kotlin/com/agorapulse/micronaut/amazon/awssdk/dynamodb/kotlin/DynamoDBEntityService.kt[tags=sample-update]

}
----
<1> Annotate an interface with `@Service` with the type of the entity as its `value`
<2> Define class which extends `com.agorapulse.micronaut.amazon.awssdk.dynamodb.kotlin.UpdateFunction` and use the DSL constructor
<3> Specify a partition key with `partitionKey` method and method's `hashKey` argument
<4> Specify a sort key with `sortKey` method and method's `rangeKey` argument
<5> Specify update operation - increment `number` attribute (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/UpdateBuilder.html[UpdateBuilder] for full reference). You may have multiple update operations.
<6> Specify what should be returned from the method (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/UpdateBuilder.html[UpdateBuilder] for full reference).
<7> `@Update` annotation accepts a class which implements `Function<Map<String, Object>, DetachedUpdate>`
<8> The arguments have no special meaning, but you can use them in the scan definition. The method's return value depends on the value returned from `returnUpdatedNew` mapper.


[source,groovy,indent=0,options="nowrap",role="secondary"]
.Groovy  (AWS SDK 1.x)
----
include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=builders-import]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=service-header]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=sample-update]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=service-footer]
----
<1> `Builders` class provides all necessary factory methods and keywords
<2> Annotate an interface with `@Service` with the type of the entity as its `value`
<3> `@Update` annotation accepts a closure which returns an update builder (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/UpdateBuilder.html[UpdateBuilder] for full reference)
<4> Specify a partition key with `partitionKey` method and method's `hashKey` argument
<5> Specify a range key with `range` method and method's `rangeKey` argument
<6> Specify update operation - increment `number` attribute (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/UpdateBuilder.html[UpdateBuilder] for full reference). You may have multiple update operations.
<7> Specify what should be returned from the method (see https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/builder/UpdateBuilder.html[UpdateBuilder] for full reference).
<8> The arguments have no special meaning but you can use them in the scan definition. The method's return value depends on the value returned from `returnUpdatedNew` mapper.

==== DynamoDB Service

`DynamoDBService` provides middle-level API for working with DynamoDB tables and entities. You can obtain instance of `DynamoDBService` from
`DynamoDBServiceProvider` which can be injected to any bean.


[source,groovy,indent=0,options="nowrap",role="primary"]
.Groovy (AWS SDK 2.x)
----

DynamoDBServiceProvider provider = context.getBean(DynamoDBServiceProvider)
DynamoDBService<DynamoDBEntity> service = provider.findOrCreate(DynamoDBEntity)         // <1>

service.createTable()                                                                   // <2>

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=save-entity,indent=0]

include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=load-entity, indent=0]

service.query {                                                                         // <5>
    partitionKey '1'
    index DynamoDBEntity.DATE_INDEX
    range { between from, to }
}

service.update {                                                                        // <6>
    partitionKey '1001'
    sortKey '1'
    add 'number', 13
    returns allNew
}

service.delete('1001', '1')                                                             // <7>
----
<1> Obtain the instance of `DynamoDBService` from `DynamoDBServiceProvider` (provider can be injected)
<2> Create table for the entity
<3> Save an entity
<4> Load the entity by its hash and range keys
<5> Query the table for entities with given range index value
<6> Increment a property for entity specified by hash and range keys
<7> Delete an entity

[source,java,indent=0,options="nowrap",role="secondary"]
.Java (AWS SDK 2.x)
----
DynamoDBServiceProvider provider = context.getBean(DynamoDBServiceProvider);
DynamoDBService<DynamoDBEntity> service = provider.findOrCreate(DynamoDBEntity.class);  // <1>

service.createTable();                                                                  // <2>

DynamoDBEntity entity = new DynamoDBEntity();
entity.setParentId("1");
entity.setId("1");
entity.setRangeIndex("foo");
entity.setNumber(1);
entity.setDate(new Date());
service.save(entity);                                                                   // <3>

service.get("1", "1");                                                                  // <4>

service.query(query ->                                                                  // <5>
    query.partitionKey("1")
    .index(DynamoDBEntity.DATE_INDEX)
    .range(r -> r.between(from, to))
);

service.update(update ->                                                                // <6>
    update.partitionKey("1001")
    .sortKey("1")
    .add("number", 13)
    .returns(ReturnValue.ALL_NEW)
);

service.delete("1001", "1");                                                            // <7>
----
<1> Obtain the instance of `DynamoDBService` from `DynamoDBServiceProvider` (provider can be injected)
<2> Create table for the entity
<3> Save an entity
<4> Load the entity by its hash and range keys
<5> Query the table for entities with given range index value
<6> Increment a property for entity specified by hash and range keys
<7> Delete an entity

[source,groovy,indent=0,options="nowrap",role="secondary"]
.Groovy (AWS SDK 1.x)
----

        DynamoDBServiceProvider provider = context.getBean(DynamoDBServiceProvider)
        DynamoDBService<DynamoDBEntity> s = provider.findOrCreate(DynamoDBEntity)       // <1>

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=create-table]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=save-entity]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=load-entity]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=query-by-range-index]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=query-by-dates]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=increment]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=delete]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=delete-all]

----
<1> Obtain the instance of `DynamoDBService` from `DynamoDBServiceProvider` (provider can be injected)
<2> Create table for the entity
<3> Save an entity
<4> Load the entity by its hash and range keys
<5> Query the table for entities with given range index value
<6> Query the table for entities having date between the specified dates
<7> Increment a property for entity specified by hash and range keys
<8> Delete an entity by object reference
<9> Delete all entities with given range index value

[source,java,indent=0,options="nowrap",role="secondary"]
.Java (AWS SDK 1.x)
----
include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DynamoDBServiceTest.java[tags=obtain-service]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DynamoDBServiceTest.java[tags=create-table]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DynamoDBServiceTest.java[tags=save-entity]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DynamoDBServiceTest.java[tags=load-entity]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DynamoDBServiceTest.java[tags=query-by-range-index]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DynamoDBServiceTest.java[tags=query-by-dates]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DynamoDBServiceTest.java[tags=increment]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DynamoDBServiceTest.java[tags=delete]

include::{root-dir}/subprojects/micronaut-aws-sdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/aws/dynamodb/DynamoDBServiceTest.java[tags=delete-all]
----
<1> Obtain the instance of `DynamoDBService` from `DynamoDBServiceProvider` (provider can be injected)
<2> Create table for the entity
<3> Save an entity
<4> Load the entity by its hash and range keys
<5> Query the table for entities with given range index value
<6> Query the table for entities having date between the specified dates
<7> Increment a property for entity specified by hash and range keys
<8> Delete an entity by object reference
<9> Delete all entities with given range index value

Please see  https://agorapulse.github.io/micronaut-amazon-awssdk/api/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DynamoDBService.html[DynamoDBService] (AWS SDK 2.x)
and https://agorapulse.github.io/micronaut-aws-sdk/api/com/agorapulse/micronaut/aws/dynamodb/DynamoDBService.html[DynamoDBService] (AwS SDK 1.x) for full reference.

==== DynamoDB Accelerator (DAX)

You can simply enable DynamoDB Accelerator by setting the DAX endpoint as `aws.dax.endpoint` property. Every operation
performed using injected `AmazonDynamoDB`, `IDynamoDBMapper` or a data service will be performed against DAX instead of
DynamoDB tables.

Please, check https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DAX.consistency.html[DAX and DynamoDB Consistency Models]
article to understand the subsequence of using DAX instead of direct DynamoDB operations.

Make sure you have set up proper policy to access the DAX cluster. See https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DAX.access-control.html[DAX Access Control] for more information.
Following policy allow every DAX operation on any resource. In production, you should constrain the scope to single cluster.

[source,json,indent=0]
.DAX Access Policy
----
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "DaxAllowAll",
            "Effect": "Allow",
            "Action": "dax:*",
            "Resource": "*"
        }
    ]
}
----


==== Testing

You can very easily mock any of the interfaces and declarative services but if you need close-to-production
DynamoDB integration works well with https://www.testcontainers.org/[Testcontainers] and https://localstack.cloud/[LocalStack] using `micronaut-amazon-awssdk-integration-testing` module.

You need to add following dependencies into your build file:


[source,indent=0,role="primary",subs='verbatim,attributes']
.Gradle
----
testImplementation 'com.agorapulse:micronaut-amazon-awssdk-integration-testing:{project-version}'
----

[source,xml,indent=0,role="secondary",subs='verbatim,attributes']
.Maven
----
<dependency>
    <groupId>com.agorapulse</groupId>
    <artifactId>micronaut-amazon-awssdk-dynamodb</artifactId>
    <version>{project-version}</version>
</dependency>
----
Then you can set up your tests like this:

[source,groovy,indent=0,role="primary"]
.Groovy
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=header]
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DefaultDynamoDBServiceSpec.groovy[tags=setup]

    // test methods

}
----
<1> Annotate the specification with `@MicronautTest` to let Micronaut handle the application context lifecycle
<2> Use `@Inject` to let Micronaut inject the beans into your tests
<3> Create the low-level service using `DynamoDBServiceProvider`

[source,java,indent=0,role="secondary"]
.Java
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/groovy/com/agorapulse/micronaut/amazon/awssdk/dynamodb/DeclarativeServiceTest.java[tags=header]
    @Inject DynamoDBServiceProvider provider                                            // <2>

    @Test
    public void testSomething() {
        DynamoDBService<DynamoDBEntity> s = provider.findOrCreate(DynamoDBEntity.class);// <3>

        // test code
    }
}
----
<1> Annotate the specification with `@MicronautTest` to let Micronaut handle the application context lifecycle
<2> Use `@Inject` to let Micronaut inject the beans into your tests
<3> Create the low-level service using `DynamoDBServiceProvider`

[TIP]
====
You can save time creating the new Localstack container by sharing it between the tests.

[source,yaml]
.application-test.yml
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb/src/test/resources/application-test.yml[]
----

Alternatively you can use different container than Localstack, for example Amazon DynamoDB Local container.

[source,yaml]
.application-test.yml
----
localstack:
  containers:
    dynamodb:
      image: amazon/dynamodb-local
      tag: 1.20.0
      port: 8000
      shared: true
  services: dynamodb
aws:
  dynamodb:
    create-tables: true
----

====

==== Data Loader

You can data exported as CSV from the AWS DynamoDB Console:

image::export-tables.png[]

These data can be loaded using `DynamoDbLoader` bean. The following test shows how to load the data from the CSV file into your DynamoDB tables. Use the integration testing library as described above to have the automatic local DynamoDB for testing.

[source,java,indent]
.DynamoDbLoader Example
----
include::{root-dir}/subprojects/micronaut-amazon-awssdk-dynamodb-loader/src/test/java/com/agorapulse/amazon/awssdk/dynamodb/loader/DynamoDbLoaderTest.java[lines=19..-1]
----
<1> Test must be annotated wiht `@MicronautTest` to allow loader injection
<2> Property `aws.dynamodb.create-tables` guarantees that the tables are created automatically
<3> https://agorapulse.github.io/testing-libraries/#_fixt[Fixt] is very convenient way how to keep your test fixtures organized and can be easily used with the loader
<4> The mapping is specified as map with the entity types as keys and iterables of the CSV files as values
<5> Load the data from the CSV file
<6> After loading the data, the entities according to the rows in the CSV file are available in the database

This is how the files are laid out for this particular example:

image:loader-layout.png[]

